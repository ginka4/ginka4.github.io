<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++命名空间的使用</title>
    <url>/2026/01/06/C++namespace/</url>
    <content><![CDATA[<p>　　在C语言发展的过程中，会碰到多个公司之间进行合作开发。当两个不同公司代码合在一起时，会出现命名冲突的情况。在C++中，引入了命名空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> name&#123;</span><br><span class="line">    <span class="type">int</span> gnum;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间的基本使用方式"><a href="#命名空间的基本使用方式" class="headerlink" title="命名空间的基本使用方式"></a>命名空间的基本使用方式</h3><p>1.作用域限定符 ::</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; wd::gnum &lt;&lt; endl;</span><br><span class="line">wd::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure>

<p>2.using编译指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>存在风险：当程序员不知道std空间中有哪些实体的情况下，会误用空间中的实体导致出现bug。不推荐使用这样的方式</p>
<p>3.using声明机制(推荐使用)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br></pre></td></tr></table></figure>

<p> 解决了方法二的缺点</p>
<h3 id="命名空间的嵌套使用"><a href="#命名空间的嵌套使用" class="headerlink" title="命名空间的嵌套使用"></a>命名空间的嵌套使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; wd::cpp::<span class="built_in">func</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>　　命名空间也可以匿名使用，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>();  <span class="comment">//等同于 ::print();</span></span><br></pre></td></tr></table></figure>

<p>　　匿名的命名空间也可以添加新的实体，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">	<span class="type">int</span> gnum=<span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　全局位置与匿名命名空间中的实体出现同名时，匿名命名空间中的同名实体会被隐藏。此外，匿名命名空间中的实体只能在本模块内部使用，与静态变量有相同的作用。</p>
<p>　　命名空间相当于是一个黑洞，可以往其中任意填充实体(实体名字不能相同)，不管是在同一个模块内部还是在不同的模块中。</p>
<h3 id="静态变量与全局变量"><a href="#静态变量与全局变量" class="headerlink" title="静态变量与全局变量"></a>静态变量与全局变量</h3><p>Q：静态变量与全局变量的区别是什么？</p>
<p>A：静态变量只能在本模块内部使用，不能跨模块使用。全局变量可以跨模块使用。</p>
<p>Q：怎么定义一个模块</p>
<p>A：一个模块就指的是一个*.c&#x2F;<em>.cpp&#x2F;.cc文件，编译时是将一个</em>.c&#x2F;*.cpp&#x2F;.cc文件作为一个编译单元的。</p>
]]></content>
      <categories>
        <category>从零开始的C++生活</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++引用</title>
    <url>/2026/01/09/C++reference/</url>
    <content><![CDATA[<p>　　C++提出引用，是为了降低使用指针带来的风险，引用本质上是一个变量的别名，引用一经初始化(绑定)以后，就不会再改变指向。 </p>
<p><img src="/../images/C++reference/image-20260113194239450.png" alt="image-20260113194348753"></p>
]]></content>
      <categories>
        <category>从零开始的C++生活</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++const关键字</title>
    <url>/2026/01/07/C++const/</url>
    <content><![CDATA[<p>　　const关键字具有只读属性，无法进行修改。</p>
<h3 id="宏定义与const常量的区别"><a href="#宏定义与const常量的区别" class="headerlink" title="宏定义与const常量的区别"></a>宏定义与const常量的区别</h3><p>Q：宏定义与const常量的区别？</p>
<p>A：发生的时机不一样，宏定义发生在预处理时，只是进行简单的文本替换。const常量发生的时机是编译时。</p>
<p>宏定义没有类型检查机制，出错时，会将发生错误的时机延迟到运行时，const常量是编译时，有类型检查机制，在编译时就可以发现问题。</p>
<p>这提醒我们，如果使用宏定义不当，发生错误的概率会更大一些，因此建议多用const关键字。</p>
<h3 id="const关键字修饰指针"><a href="#const关键字修饰指针" class="headerlink" title="const关键字修饰指针"></a>const关键字修饰指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p2 = &amp;num；<span class="comment">//p2不能修改所指空间的内容，但依然可以改变p2的指向</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * p1 = &amp;num;<span class="comment">//p1不能修改所指空间的内容，但依然可以改变p1的指向</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p3 = &amp;num;<span class="comment">//p3可以修改所指空间的内容，但不能改变p3的指向</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p1 = &amp;num;<span class="comment">//const的双重限定，两者都不能进行修改</span></span><br></pre></td></tr></table></figure>

<h3 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h3><h4 id="常量指针-vs-指针常量"><a href="#常量指针-vs-指针常量" class="headerlink" title="常量指针 vs 指针常量"></a>常量指针 vs 指针常量</h4><p>常量指针：首先是一个指针，指向的是常量，意味着不能修改指针所指的内容</p>
<p>指针常量：首先是一个常量，指针本身不能改变指向</p>
<h4 id="数组指针-vs-指针数组"><a href="#数组指针-vs-指针数组" class="headerlink" title="数组指针 vs 指针数组"></a>数组指针 vs 指针数组</h4><p>数组指针：首先是一个指针，指向的是一个数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>指针数组：首先是一个数组，数组中存放的是指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *arr2[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h4 id="函数指针-vs-指针函数"><a href="#函数指针-vs-指针函数" class="headerlink" title="函数指针 vs 指针函数"></a>函数指针 vs 指针函数</h4><p>函数指针：首先是一个指针，指向的是一个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)();</span><br></pre></td></tr></table></figure>

<p>指针函数：首先是一个函数，函数的返回值是指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零开始的C++生活</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++new/delete</title>
    <url>/2026/01/08/C++new_delete/</url>
    <content><![CDATA[<p>　　发</p>
<h3 id="varlgrind工具的使用"><a href="#varlgrind工具的使用" class="headerlink" title="varlgrind工具的使用"></a>varlgrind工具的使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">valgrind --tool=memcheck ./a.out</span><br></pre></td></tr></table></figure>

<p>可以查看内存是否泄露。</p>
<p>内存泄露：服务器程序是需要7*24小时稳定运行，如果不注意内存回收的操作，执行的过程中可用内存会一直减少，直到内存耗尽，程序就崩溃。</p>
<h3 id="malloc-free与new-delete"><a href="#malloc-free与new-delete" class="headerlink" title="malloc&#x2F;free与new&#x2F;delete"></a>malloc&#x2F;free与new&#x2F;delete</h3><p>Q：malloc&#x2F;free与new&#x2F;delete有什么区别？</p>
<p>A：malloc&#x2F;free是标准库函数，new&#x2F;delete是表达式。</p>
<p>malloc申请的空间没有执行初始化操作，new表达式在执行时可以同时完成初始化操作。</p>
<p>malloc参数传递的是申请的字节数，new表达式不需要指定字节数，会根据类型自动获取空间大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * p1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();<span class="comment">//开辟数组的空间，需要使用中括号[]</span></span><br><span class="line"><span class="type">int</span> * p1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];<span class="comment">//不加小括号，无法保证申请数组时清零，加上小括号会进行清零操作</span></span><br><span class="line"><span class="keyword">delete</span> [] p1;<span class="comment">//对于数组的回收，一定要加上中括号</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从零开始的C++生活</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的使用</title>
    <url>/2026/01/04/the_use_of_vim/</url>
    <content><![CDATA[<p>　　本文章主要讲述了vim的基本使用方法，来源于vimtutor，仅供读者入门使用。</p>
<h3 id="第一讲总结"><a href="#第一讲总结" class="headerlink" title="第一讲总结"></a>第一讲总结</h3><p><img src="/../images/the_use_of_vim/1.png" alt="1"></p>
<h3 id="第二讲总结"><a href="#第二讲总结" class="headerlink" title="第二讲总结"></a>第二讲总结</h3><p><img src="/../images/the_use_of_vim/image-20260104164716929-1767519646133-5.png" alt="image-20260104164716929-1767519646133-5"></p>
<h3 id="第三讲总结"><a href="#第三讲总结" class="headerlink" title="第三讲总结"></a>第三讲总结</h3><p><img src="/../images/the_use_of_vim/image-20260104164741092-1767519667650-8.png" alt="image-20260104164741092-1767519667650-8"></p>
<h3 id="第四讲总结"><a href="#第四讲总结" class="headerlink" title="第四讲总结"></a>第四讲总结</h3><p><img src="/../images/the_use_of_vim/image-20260104164808576-1767519676759-11.png" alt="image-20260104164808576-1767519676759-11"></p>
<h3 id="第五讲总结"><a href="#第五讲总结" class="headerlink" title="第五讲总结"></a>第五讲总结</h3><p><img src="/../images/the_use_of_vim/image-20260104164833643-1767519696256-14.png" alt="image-20260104164833643-1767519696256-14"></p>
<h3 id="第六讲总结"><a href="#第六讲总结" class="headerlink" title="第六讲总结"></a>第六讲总结</h3><p><img src="/../images/the_use_of_vim/image-20260104164851791-1767519703908-17-1767520133008-22.png" alt="image-20260104164851791-1767519703908-17-1767520133008-22"></p>
<h3 id="第七讲总结"><a href="#第七讲总结" class="headerlink" title="第七讲总结"></a>第七讲总结</h3><p><img src="/../images/the_use_of_vim/image-20260104170303025-1767519712609-20.png" alt="image-20260104170303025-1767519712609-20"></p>
<h3 id="在vim中以多标签方式打开文件"><a href="#在vim中以多标签方式打开文件" class="headerlink" title="在vim中以多标签方式打开文件"></a>在vim中以多标签方式打开文件</h3><p>1.先打开hello.c文件</p>
<p>2.用命令行模式</p>
<p>3.在多标签中进行切换</p>
<p>   ctrl+n 下一个标签</p>
<p>   ctrl+p 下一个标签</p>
<p>4.关闭某一个标签，使用命令行模式</p>
<p>   :bd</p>
]]></content>
      <categories>
        <category>从零开始的Linux生活</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件的操作</title>
    <url>/2025/12/30/Linux_file/</url>
    <content><![CDATA[<p>　　本文章主要讲解了入门Linux系统的基本文件操作方法，供读者入门参考。</p>
<h3 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h3><p>1.cat&gt;file1</p>
<p>直接用键盘写文件内容，结束输入用ctrl+d</p>
<p>重定向符号 &gt; ，管道pipe</p>
<p>2.echo hello&gt;test2</p>
<p>默认情况下，会有一个\n写入文件</p>
<p>echo -n hello&gt;test2</p>
<p>当echo使用了-n选项之后，可以去掉\n换行符</p>
<p>3.touch file3</p>
<p>4.vim file4</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>1.ln命令</p>
<p>初始情况下，file1的初始链接数为1</p>
<p>创建file1的硬链接file2，之后发现硬链接数变成了2</p>
<p>file1于file2是同一个文件</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>1.ln -s test1 stest1</p>
<p>作用类似于Windows中的快捷方式</p>
<h3 id="文件的权限修改"><a href="#文件的权限修改" class="headerlink" title="文件的权限修改"></a>文件的权限修改</h3><p>1.文字设定法</p>
<p>chmod u+x,g+x ycm.py</p>
<p>2.数字设定法</p>
<p>chmod 640 ycm.py</p>
<h3 id="文件的拷贝-复制"><a href="#文件的拷贝-复制" class="headerlink" title="文件的拷贝(复制)"></a>文件的拷贝(复制)</h3><p>1.cp命令</p>
<p>cp ycm.py .&#x2F;test&#x2F;dir1&#x2F;</p>
<p>复制文件的同时 ，修改文件的名字</p>
<p>cp ycm.py .&#x2F;test&#x2F;dir1&#x2F;file3.py</p>
<p>2.拷贝文件夹(目录) 加-r,递归执行</p>
<p>在同一个父目录复制文件夹，同时还修改了文件夹的名字</p>
<p>cp -r test test2</p>
<p>在不同目录下</p>
<p>cp -r test2 ~&#x2F;</p>
<p>3.跨主机传输文件</p>
<p>scp 源文件的位置 目的主机的位置</p>
<p>​               user@host:&#x2F;path</p>
<p>然后输入目的主机的相应用户的密码</p>
<p>4.移动文件</p>
<p>mv(move) 源文件 目的地</p>
<p>mv ycm.py test&#x2F;dir2&#x2F;</p>
<p>5.重命名功能</p>
<p>对同一目录下的文件进行重命名</p>
<p>mv test2 test3</p>
<h3 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h3><p>1.rm test4</p>
<p>删除单独的文件</p>
<p>2.rm ~&#x2F;test2&#x2F;test3</p>
<p>删除不同的目录下的文件</p>
<p>3.目录的删除</p>
<p>rm test3 -r      -r为递归删除</p>
<p>rm -r ~&#x2F;test2</p>
<h3 id="文件的查找"><a href="#文件的查找" class="headerlink" title="文件的查找"></a>文件的查找</h3><p>1.find ~&#x2F; -name stdio.h</p>
<p>find 查找位置 按文件名 文件名</p>
<p>在根目录下查找时，前面加sudo提升权限</p>
<p>2.grep 要过滤的关键字 指定要查找的位置 -rn</p>
<p>grep string .&#x2F; -rn</p>
<p>-r表示递归查找 -n表示显示关键字在文件中的行号</p>
<h3 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h3><p>1.tar命令</p>
<p>只打包，没有压缩的效果</p>
<p>tar -cvf day02.tar day02&#x2F;</p>
<p>压缩的效果</p>
<p>tar -zcvf day02.tar.gz day02</p>
<h3 id="拆包和解压缩"><a href="#拆包和解压缩" class="headerlink" title="拆包和解压缩"></a>拆包和解压缩</h3><p>1.只拆包，没有解压缩</p>
<p>tar -xvf day02.tar</p>
<p>解压缩</p>
<p>tar -zxvf day02.tar.gz</p>
<p>2.解压Windows生成的*.zip的压缩文件</p>
<p>unzip Linux.zip</p>
<h3 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h3><p>1.df -h 查看磁盘</p>
<p>2.free -h 查看内存</p>
<h3 id="对一个命令设置别名"><a href="#对一个命令设置别名" class="headerlink" title="对一个命令设置别名"></a>对一个命令设置别名</h3><p>第一步，找到用户家目录下的.bashrc文件</p>
<p>第二步，在该文件的末尾加上新的一行，使用alias命令起别名</p>
<p>第三步，重新加载该文件</p>
<p>$ source ~&#x2F;.bashrc</p>
<p>第四步，使用新命令</p>
<h3 id="获取内核以及操作系统的信息"><a href="#获取内核以及操作系统的信息" class="headerlink" title="获取内核以及操作系统的信息"></a>获取内核以及操作系统的信息</h3><p>1.uname -a</p>
<p>2.lsb_release -a</p>
<p>3.cat &#x2F;etc&#x2F;issue </p>
]]></content>
      <categories>
        <category>从零开始的Linux生活</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++强制类型转换&amp;函数重载与默认参数</title>
    <url>/2026/01/13/C++change/</url>
    <content><![CDATA[<p>　　C++强制(类型)转换、函数重载与默认参数。</p>
<p><img src="/../images/C++change/image-20260113210040415.png" alt="image-20260113210040415"></p>
]]></content>
      <categories>
        <category>从零开始的C++生活</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
